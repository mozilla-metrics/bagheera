package com.mozilla.bagheera.metrics;

import com.yammer.metrics.Metrics;
import com.yammer.metrics.core.*;
import com.yammer.metrics.core.Timer;
import com.yammer.metrics.reporting.AbstractPollingReporter;
import com.yammer.metrics.core.MetricPredicate;

import java.awt.*;
import java.io.IOException;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.TimeUnit;

import org.apache.log4j.Logger;
import org.rrd4j.ConsolFun;
import org.rrd4j.DsType;
import org.rrd4j.core.*;
import org.rrd4j.graph.RrdGraph;
import org.rrd4j.graph.RrdGraphDef;
import java.awt.image.BufferedImage;
import java.io.File;

// TODO Handle meter, histogram and timer

/**
 * A simple reporter which stores the metric values in RRD files
 */
public class Rrd4jReporter extends AbstractPollingReporter implements
    MetricProcessor<Rrd4jReporter.Context> {

    public static final Integer MAX_DB_UPDATE_INTERVAL = 15;
    private static final Logger LOG = Logger.getLogger(Rrd4jReporter.class);
 
    private HashMap<String, RrdDb> rrdMap = null;
    private final File dataDir, graphDir;
    private final Integer graphUpdateInterval, dbUpdateInterval; // generate graphs every N seconds
    private long lastGraphGeneratedAt = 0;
    private Boolean generateGraphs = false;

    private void generateGraphForMetric(MetricName name, String units) throws IOException {
        LOG.debug("generating graphs for " + name.getName());

        RrdGraphDef graphDef = new RrdGraphDef();
        graphDef.datasource(name.getName(), getMetricDBPath(name).toString(), "value", ConsolFun.AVERAGE);

        graphDef.line(name.getName(), new Color(0xFF, 0, 0), null, 2);
        graphDef.setFilename(getMetricGraphPath(name).toString());

        graphDef.setStartTime(-3600);
        graphDef.setEndTime(-1);

        graphDef.setVerticalLabel(units);
        graphDef.setTitle(name.getName());
        RrdGraph graph = new RrdGraph(graphDef);
        BufferedImage bi = new BufferedImage(100,100,BufferedImage.TYPE_INT_RGB);
        graph.render(bi.getGraphics());
    }

    private File getMetricDBPath(MetricName name) {
        return new File(this.dataDir, name.getName() + "-" + this.dbUpdateInterval + ".rrd");
    }

    private File getMetricGraphPath(MetricName name) {
        return new File(this.graphDir, name.getName() + "-" + this.dbUpdateInterval + ".gif");
    }

    private RrdDb createDB(MetricName name, DsType metricType) throws IOException {

        Integer stepsPerMin = (int) Math.round(60 / this.dbUpdateInterval);
        Integer stepsPerHour = (int) Math.round(3600 / this.dbUpdateInterval);

        HashMap<Integer, Integer> archives = new HashMap<Integer, Integer>();
        // 60 * 24 * 7 samples of 1min average
        archives.put(stepsPerMin, 10080);
        // 24 * 30 samples of 1hr average
        archives.put(stepsPerHour, 720);
        return createDB(name, metricType, this.dbUpdateInterval, archives);
    }

    private RrdDb createDB(MetricName name, DsType metricType, Integer stepSize,
                           HashMap<Integer, Integer> archives) throws IOException {

        File metricDBPath = getMetricDBPath(name);

        // create new DB
        RrdDef rrdDef = new RrdDef(metricDBPath.toString(), stepSize);
        rrdDef.setStartTime((System.currentTimeMillis() / 1000) - stepSize);
        rrdDef.addDatasource("value", metricType, 2 * stepSize, Double.NaN, Double.NaN);
        for (Entry<Integer, Integer> entry : archives.entrySet()) {
            rrdDef.addArchive(ConsolFun.AVERAGE, 0.5, entry.getKey(), entry.getValue());
        }

        RrdDb rrdDb = new RrdDb(rrdDef);
        this.rrdMap.put(name.getName(), rrdDb);
        return rrdDb;
    }

    public RrdDb getDBHandle(MetricName name) throws IOException {

        File metricDBPath = getMetricDBPath(name);

        if (!metricDBPath.exists())
            return null; // old/inconsistent metrics can be regenerated by simply them from local FS
        
        if (this.rrdMap.containsKey(name.getName()))
            return this.rrdMap.get(name.getName());

        if (metricDBPath.exists()) {
            this.rrdMap.put(name.getName(), new RrdDb(metricDBPath.toString()));
            return rrdMap.get(name.getName());
        }

        return null;
    }

    public static void enable(Integer period, TimeUnit unit, File dataDir, File graphDir, Integer graphUpdateInterval) {
        enable(Metrics.defaultRegistry(), period, unit, dataDir, graphDir, graphUpdateInterval);
    }

    public static void enable(MetricsRegistry metricsRegistry, Integer period, TimeUnit unit,
                              File dataDir, File graphDir, Integer graphUpdateInterval) {
        final Rrd4jReporter reporter = new Rrd4jReporter(metricsRegistry, MetricPredicate.ALL,
            dataDir, period, graphDir, graphUpdateInterval);
        reporter.start(period, unit);
    }

    private final MetricPredicate predicate;

    public Rrd4jReporter(MetricsRegistry metricsRegistry,
                           MetricPredicate predicate,
                           File dataDir,
                           Integer dbUpdateInterval,
                           File graphDir,
                           Integer graphUpdateInterval) {
        super(metricsRegistry, "rrd4j-reporter");
        this.predicate = predicate;
        this.dataDir = dataDir;
        this.dbUpdateInterval = Math.min(MAX_DB_UPDATE_INTERVAL, dbUpdateInterval);
        this.graphDir = graphDir;
        this.graphUpdateInterval = graphUpdateInterval;
        this.rrdMap = new HashMap<String, RrdDb>();
    }

    /**
     * The context used to output metrics.
     */
    public interface Context {

    }

    @Override
    public void run() {

        if (((System.currentTimeMillis()/1000) - this.lastGraphGeneratedAt) > this.graphUpdateInterval)
            generateGraphs = true;

        try {
            for (Entry<String, SortedMap<MetricName, Metric>> entry : getMetricsRegistry().groupedMetrics(
                predicate).entrySet()) {
                for (Entry<MetricName, Metric> subEntry : entry.getValue().entrySet()) {
                    try {
                        subEntry.getValue().processWith(this, subEntry.getKey(),null);
                    } catch (IOException e) {
                        LOG.error("Unable to update RRD database for metric " + subEntry.getKey().getName(), e);
                    }
                }
            }
        } catch (Exception e) {
            LOG.error(e);
        }

        if (generateGraphs) {
            this.lastGraphGeneratedAt = System.currentTimeMillis()/1000;
            this.generateGraphs = false;
        }
    }

    private void processMetric(MetricName name, DsType metricType, Double value, String units) throws IOException {
        RrdDb db = this.getDBHandle(name);
        if (db == null) {
            db = createDB(name, metricType);
        }

        try {
            Sample s = db.createSample();
            s.setAndUpdate(System.currentTimeMillis()/1000 + ":" + value);
        } catch (IOException e) {
            LOG.warn("Unable to commit value for metric " + name.getName(), e);
            return;
        }

        try {
            if (this.generateGraphs)
                generateGraphForMetric(name,  units);
        } catch (IOException e) {
            LOG.warn("Unable to generate graphs for metric " + name.getName(), e);
        }
    }

    @Override
    public void processGauge(MetricName name, Gauge<?> gauge, Context ctx) throws IOException {
        final Object value = gauge.value();
        final Class<?> klass = value.getClass();
        Double mval = 0.0;

        if (klass == Integer.class || klass == Long.class || klass == Float.class || klass == Double.class) {
            mval = (Double) value;
        }
        else {
            LOG.info("Ignoring RRD updates for non-numeric metric " + name);
            return;
        }

        processMetric(name, DsType.GAUGE, mval, "");
    }

    @Override
    public void processCounter(MetricName name, Counter counter, Context ctx) throws IOException {
        processMetric(name, DsType.COUNTER, 1.0 * counter.count(), "");
    }

    @Override
    public void processMeter(MetricName name, Metered meter, Context ctx) {
    }

    @Override
    public void processHistogram(MetricName name, Histogram histogram, Context ctx) {
    }

    @Override
    public void processTimer(MetricName name, Timer timer, Context ctx) {
    }
}
